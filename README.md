# Блокировки
В РФ ввели интернет-цензуру, в связи с этим провайдеров обязали устанавливать "чёрные ящики".
"Ящики" называются ТСПУ, что значит "Технические Средства Противодействия Угрозам".

## ТСПУ
ТСПУ является комплексом средств для блокировки, который расположен на серверах. Одним из средств является DPI (Deep Packet Inspection, Глубокая Проверка Пакета), который можно обойти с помощью ByeDPI.

> [!TIP]
> *Не путайте ByeDPI и DPI*. Если вы хотите сократить, то пишите "бд" или "bd"


# Обход блокировок по DPI (атака DPI, десинхронизация и прочие синонимы)
Целью атаки является сделать начало соединения (TLS Handshake - TLS Рукопожатие) незаметным для DPI и установить безопасное соединение (HTTPS) с сайтом.
После DPI не сможет прервать соединение

<details><summary>О TLS Handshake (упрощённая версия статьи из Википедии)</summary>
	
	
```
  Как устанавливается безопасное соединение (на примере TLS 1.2)
  
  1. Начало договора:
  Наш клиент (допустим, браузер) посылает TLS Record (TLS Запись, в неё входит информация о клиенте) ClientHello (в переводе: Привет от Клиента), в котором указаны: версия TLS-протокола, которую поддерживает клиент, случайные данные и список поддерживаемых методов шифрования (cipher suites), подходящих для работы с TLS.
  
  2. Обработка запроса сервером
     
  Сервер даёт ServerHello (Привет от сервера), содержащий: выбранную сервером версию TLS (у сервера здесь приемущество), случайное число, сгенерированное сервером, выбранный метод шифрования из тех, что дал клиент.

  2.1. Сервер отправляет свой цифровой сертификат сервера (в зависимости от версии TLS этот этап может быть пропущен).
  
 3. Если клиенту мало данных для шифрования
    
  Если переданных сервером данных мало, то сервер передаёт сообщение ServerKeyExchange, в котором передаются необходимые данные, которые затребовал клиент.

 3.1. Сервер отсылает ServerHelloDone, означающее конец первого раунда установления соединения.
    
 3.2 Клиент даёт ClientKeyExchange, которое содержит клиентскую часть протокола Диффи-Хеллмана или зашифрованный открытым ключом из сертификата сервера (PreMasterSecret).
    
 3.3. Клиент и сервер, используя ключ PreMasterSecret и случайно сгенерированные числа, вычисляют общий секрет. Вся остальная информация о сеансовом ключе будет получена из общего секрета.
    
 3.4. Клиент посылает ChangeCipherSpec, которое указывает на то, что вся последующая информация будет зашифрована в процессе подтверждения связи алгоритмом, используя общий секретный ключ.
    
 4. Последний этап
    
 4.1. Клиент посылает Finished, которое содержит данные, сгенерированные на основе предыдущих сообщений процедуры подтверждения связи.
 
 4.2. Сервер пытается расшифровать Finished-сообщение клиента и проверить эти данные. Если процесс расшифровки или проверки не удаётся - соединение должно быть оборвано.
 
 4.3. Сервер посылает ChangeCipherSpec и зашифрованный Finished (клиент тоже проверит всё).

 5. Соединение установлено (в обычных условиях соединение может занять до 3-5 секунд).
 ```
</details>

<details><summary>Содержание TLS Record (TLS Запись) для ClientHello</summary>
	
```
Состоит из байтов, которые принимают различные значения. 
Смещение байтов - положение ячейки(!).
Счёт смещения начинается с нуля(!).
```

<table>
    <tr>
        <th>Смещение</th>
        <th>Значение</th>
        <th>Доп. информация</th>
    </tr>
    <tr>
        <td>0</td>
        <td>Содержимое пакета</td>
        <td>Значения от 0x14-0x17</td>
    </tr>
    <tr>
        <td>1-2</td>
        <td>Версия TLS</td>
        <td>1 - мажорная. 2 - минорная</td>
    </tr>
    <tr>
        <td>3-4</td>
        <td>Длина Записи</td>
        <td>Значения до 16.384 (0x00 0x00 - 0x40 0x00)</td>
    </tr>
    <tr>
        <td>5-36</td>
        <td>Random (случайн. инф.)</td>
        <td>Состоит из 2 частей: UNIX Время и случайные значения</td>
    </tr>
    <tr>
        <td>37</td>
        <td>Длина ID сессии</td>
        <td>Session ID, идентификатор сессии</td>
    </tr>
    <tr>
        <td>38-?</td>
        <td>Session ID</td>
        <td>Может быть использован для восстановления соединения или идентификации пользователя</td>
    </tr>
</table>
</details>

<details><summary>Значения 0 байта в TLS Record</summary>
  Значения:

<table>
    <tr>
        <th>Значения байта</th>
        <th>Описание</th>
    </tr>
    <tr>
        <td>0x14</td>
        <td>Change Cipher Spec (Предупреждение сервера о переходе на TLS)</td>
    </tr>
    <tr>
        <td>0x15</td>
        <td>Alert (Сообщения об ошибках)</td>
    </tr>
    <tr>
        <td>0x16</td>
        <td>Handshake (Обмен сообщениями для шифрования трафика</td>
    </tr>
       <tr>
        <td>0x17</td>
        <td>Application Data (Уже зашифрованный трафик</td>
    </tr>
</table>
</details>

## Виды атак, их описания и немного теории
Атаки могут быть разных видов.
* В ByeDPI их несколько:
  * Split - нарезка по указанным позициям.
  
  * Disoder - обратная отправка. (По какой причине оно так отправляет, расскажу далее)
    
  * OOB - (Out-Of-Band - Вне очереди) имеет пометку, как срочный (URG флаг)
    
  * OOB Disoder - disorder с пометкой "срочный".
 
  * FAKE - является disoder'ом с подмешиванием сгенерированных пакетов в поток.
  * UDP Fake - сгенерировать UDP пакет.

  ### Что такое UDP и TCP?
  Это протоколы (правила общения между Вами и сайтом, условно языки), созданные с упором на определённые цели. Вот приемущества этих протоколом:
  
  * TCP (Подходит для сайтов)
    * Имеет гарантии доставки и целостности данных, переотправляя потерянные пакеты при обнаружении пропажи (при использовании TCP/IP, если пакет будет испорчен для чтения или просто потерян, нужная сторона отправит его сново).
      
    * Защищает данные за счёт SSL (протокол, предназначенный для защиты соединений) шифрования с помощью TLS.
    * Имеет более низкие скорости, чем UDP, из-за установки безопасного соединения и проверки целостности.

  * UDP (Подходит для медиа или звонков)
    * Высокая скорость.
    * Отсутствие шифрования (хотя для UDP можно использовать DTLS - аналог TLS для UDP).

 # Пояснения работы аргументов

 ## Disorder
  TCP пакет делится на две части (1 пакет — на указанной позиции, 2 пакет — после указанной позиции).

  1 пакет отправляют с маленьким временем жизни (1 TTL, далее описанно про него) и он не успеет дойти до сервера.

  2 пакет отправляется без особых изменений (как TCP-пакету ByeDPI должен дать ему заголовок, иначе он будет считаться непригодным)

Как только окажется, что 1 пакет пропал его переотправит.

 ## OOB

  TCP пакет делится на две части.

  1 пакет получает метку отправки вне очереди (URG флаг), он создаст один лишний байт в пакете, но будет усечён.

  2 пакет также без особых изменений пройдёт.

 # Как атаковать DPI?
 
   ### Стратегии
   
Стратегии - это группа/набор групп из аргументов

   ###  Группы
   Группы - это наборы аргументов на определённые случаи (подозрения в блокировке, при поломке SSL, для определённого домена/IP и т.д). Их можно различать по флагу -A, он позволяет как раз наладить автоматизацию в стратегии

   Значения -A:

-At — если ByeDPI обнаружил блокировку соединения, то применит эту группу

-Ar — если ByeDPI заметит подмену IP адреса (такое может происходить, если оператор уведомляет о блокировке), то применит эту группу

-As — если произойдёт поломка SSL, то ByeDPI применит эту групп

-An — выход из группы с ограничителем (устанавливайте в начале стратегии эти группы: -Ku -a5 -An -J:"127.0.0.1/24" -d3 -An -o2)

   ###  
   
  ## Атака в действии
 Возьмём для примера стратегию -o2 -d3.
Разберём её: у нас есть одна группа, в которой есть OOB со значением 2 и Disoder со значением 3.

Порядок отправки: 1-3 как "срочные", 3-?, 1-3 (не как "срочные"). 

Такая атака способна сбить ТСПУ с толку, но тут зависит от фильтров

<details><summary>Примеры для остальных аргументов</summary>

```
Split 3 (-s3)
Порядок отправки: 1-3, 3-?.

FAKE -1 (-f-1)
Если в значении есть "-", то он будет отправлен в конце.
(в примере для различия: o - оригинальные данные, f - сгенерированные)
Порядок отправки: 1o, 1-?o, 1f. (Если значение было бы не отрицательное: 1o, 1f, 1-?o).

OOB Disoder 2 (-q2)
2-?, 1-3 (с OOB, не забываем, что появляется вспомогательный байт).
```
</details>

Стратегия может сочетать в себе сценарии на вид протокола, на домены (как раз "ограничители")

Воспользуемся -K (ограничитель по протоколу) со значением "u", получается мы создали ограничитель по UDP.
Укажем ей аргумент: -Ku -a3.

3 в большинстве случаев хватает, но по желанию можно повысить (-A для смены группы).

Давайте теперь укажем стратегию на остальные случаи: -Ku -a3 -An -o2 -d3.

Разберём её: для UDP соединений отправляется 3 UDP-Fake'а, а на остальное применяется вторая группа: 1-3 как "срочные", 3-?, 1-3 (не как "срочные").

Поздравляю, мы изобрели "свою" стратегию. Можем дополнить её, например, поработать с FAKE.

# Как манипулировать TCP FAKE'ом

В ByeDPI есть флаги, позволяющие изменять Fake'и на вкус и цвет.

Хотите составить свои данные для Fake'а?

-l:"*последовательности по типу: \xoo\n\t*", но сейчас не об этом.

Наша цель: довести Fake до ТСПУ и, чтобы он не дошёл до сервера.

Чуть об устройстве TCP: У всех пакетов есть время жизни (TTL, Time-To-Live), оно может иметь разные значения в зависимости от ОС, в основном 64 и 128, а максимальное время жизни - 255. (Время измеряется в кол-ве маршрутизаторов, через которые прошёл пакет).

Мы можем пойти по двум вариантам: *играть со значением TTL* или *совмещать Fake с Disoder*.
* Подбор TTL (*-t*)
  * Подбирать индивидуальное значение под Fake, пока не найдёте лучшее значение.

* Установка Disoder
  * По инструкции от @hufrea (автор ByeDPI) при *-d1 -f7* наш фейк дойдёт до сервера, но будет перезаписан.
  * (При использовании на Android (к примеру, ByeByeDPI) или Linux-подобных можно установить -S в стратегию
    Таким образом сервер если поддерживает MD5 проверку, то он будет отбрасывать FAKE).

## Дополнение стратегии
  *Мне мало YouTube!*
  
  *Окей.*
 
Сейчас мы дополним нашу стратегию: -Ku -a3 -An -o2 -d3.
Допустим, мы хотим избежать блокировки, но 2 группа хорошо справляется с другими сервисами.

- Что же делать?
  
- Создать группы на необходимый случай!
  
Берём -Ku -a3 -An -o2 -d3, добавляем -At,r (группа на случай, если соединение будет сброшено или перехвачено для переброса на страницу о блокировке).
> -Ku -a3 -An -o2 -d3 -At,r -f-1+hme -d3 -t5

Хотя если есть проблемы с доступом к определённым доменам:
* Проверьте, что домен в той форме, в которой вы запрашиваете соединение существует
   * Откройте домен в браузере (к примеру, в подборе на момент ByeByeDPI 1.6.9 присутствует домен discord.design, которого нет)
   * Если вышло DNS_PROBE_FINISHED_NXDOMAIN, то попробуйте сменить DNS, если не помогло: домена нет

     
* Добавьте группу с ограничителем
  * К примеру, допустим, что у нас не работает видео в YouTube
  * Это означает, что у нас возникла проблема с googlevideo.com (у GoogleVideo есть множество доменов) 

Проверим её.
Теперь у меня заработал YouTube и Discord (не гарантированно у вас).

  # Прочая информация, которую можно использовать в стратегиях

 ### -n - SNI для Fake'а 
Мы можем дополнительно установить SNI (Server Name Indication - Индикатор Имени Сервера).
Допустим, fonts.google.com.
  
> -Ku -a3 -An -o2 -d3 -At,r -f-1+hme -d3 -t5 -n fonts.google.com

 ### -Q - CH (ClientHello) для Fake'а
  * -Qr - случайные данные (если указанны другие параметры, то они будут с приоритетом)
  * -Qo - изпользовать обычный CH
  * -Qm=? - размер FAKE пакета (? замените на нужное кол-во байтов)

 ### -r - нарезка CH
  В списке "Содержание TLS Record (TLS Запись) для ClientHello" описанны смещения
  Суть изпользования: сделать Запись нечиталебльно для DPI (хотя взависимости от провайдера ТСПУ можеты склеивать дробёжку Записи)
  
  Если писать -r?+s, то разрез будет на ? байте после SNI в ClientHello

  ### -m - визуальная смена версии TLS
  Описанием всё сказанно: меняет третий байт TLS Record
  
  -m1 - TLS 1.0
  
  -m2 - TLS 1.1
  
  -m3 - TLS 1.2

 ### -Y игнорировании SACK проверки
 
   ByeDPI заставит игнорировать SACK, тем самым заставит постоянно переотправлять пакеты, даже если они целы и не имеют дефектов.
   
   Может помочь, если сервер зажуёт FAKE пакет и будет воспринимать его за настоящий.

 ### -S — MD5 проверка
 > [!TIP]
 > Данный аргумент лучше использовать на Linux-подобных ОС

  ByeDPI просит сервер проверять пакеты на предмет FAKE

  Если сервер заметит такой пакет, то отклонит

  (Он всё равно не для сервера, но лучше будет подбор TTL илм ретрансмиссионным подходом)
